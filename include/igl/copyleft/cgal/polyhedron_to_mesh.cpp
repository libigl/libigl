// This file is part of libigl, a simple c++ geometry processing library.
// 
// Copyright (C) 2015 Alec Jacobson <alecjacobson@gmail.com>
// 
// This Source Code Form is subject to the terms of the Mozilla Public License 
// v. 2.0. If a copy of the MPL was not distributed with this file, You can 
// obtain one at http://mozilla.org/MPL/2.0/.
#include "polyhedron_to_mesh.h"
#include <CGAL/Polyhedron_3.h>
#include "assign_scalar.h"
#include <unordered_map>

namespace
{

  template <
    typename Polyhedron,
    typename DerivedV>
  inline void polyhedron_to_mesh_helper_vertices(
    const Polyhedron & poly,
    Eigen::PlainObjectBase<DerivedV> & V,
    std::unordered_map<typename Polyhedron::Vertex_const_iterator,size_t> & vertex_to_index)
  {
    using namespace igl::copyleft::cgal;
    V.resize(poly.size_of_vertices(),3);
    size_t v = 0;
    for(
      typename Polyhedron::Vertex_const_iterator p = poly.vertices_begin();
      p != poly.vertices_end();
      p++)
    {
      assign_scalar(p->point().x(),V(v,0));
      assign_scalar(p->point().y(),V(v,1));
      assign_scalar(p->point().z(),V(v,2));
      vertex_to_index[p] = v;
      v++;
    }
  }
}

template <
  typename Polyhedron,
  typename DerivedV,
  typename DerivedF>
IGL_INLINE void igl::copyleft::cgal::polyhedron_to_mesh(
  const Polyhedron & poly,
  Eigen::PlainObjectBase<DerivedV> & V,
  Eigen::PlainObjectBase<DerivedF> & F)
{
  std::unordered_map<typename Polyhedron::Vertex_const_iterator,size_t> vertex_to_index;
  polyhedron_to_mesh_helper_vertices(poly,V,vertex_to_index);

  F.resize(poly.size_of_facets(),3);
  {
    int f = 0;
    for(
      typename Polyhedron::Facet_const_iterator facet = poly.facets_begin();
      facet != poly.facets_end();
      ++facet)
    {
      typename Polyhedron::Halfedge_around_facet_const_circulator he = 
        facet->facet_begin();
      // Facets in polyhedral surfaces are at least triangles.
      assert(CGAL::circulator_size(he) == 3 && "Facets should be triangles");
      int c = 0;
      do {
        //// This is stooopidly slow
        // F(f,c) = std::distance(poly.vertices_begin(), he->vertex());
        F(f,c) = vertex_to_index[he->vertex()];
        c++;
      } while (++he != facet->facet_begin());
      f++;
    }
  }

}

template <
  typename Polyhedron,
  typename DerivedV,
  typename DerivedI,
  typename DerivedC
  >
IGL_INLINE void igl::copyleft::cgal::polyhedron_to_mesh(
  const Polyhedron & poly,
  Eigen::PlainObjectBase<DerivedV> & V,
  Eigen::PlainObjectBase<DerivedI> & I,
  Eigen::PlainObjectBase<DerivedC> & C)
{
  // I think even the unordered_map can be avoided if we const expr detect that 
  // the Polyhedron uses items with id and then use that id as the index.
  //
  // It would... But the caller needs to not only use Polyhedron_items_with_id_3
  // but needs to loop over vertices and set v->id() = i++ before calling this
  // function (or this function needs to do that but then poly can't be a const
  // input anymore).
  //
  // Probably there should be a special version of this function where the user
  // can promise that ids have been set.
  std::unordered_map<typename Polyhedron::Vertex_const_iterator,size_t> vertex_to_index;
  polyhedron_to_mesh_helper_vertices(poly,V,vertex_to_index);
  C.resize(poly.size_of_facets() + 1);
  I.resize(poly.size_of_halfedges());
  {
    int f = 0;
    C(0) = 0;
    int i = 0;
    for (auto fit = poly.facets_begin(); fit != poly.facets_end(); ++fit, ++f)
    {
      auto he = fit->halfedge();
      const auto he0 = he;
      int deg = 0;
      do
      {
        //I(i++) = std::distance(poly.vertices_begin(), he->vertex());
        I(i++) = vertex_to_index[he->vertex()];
        deg++;
        he = he->next();
      } while (he != he0);
      C(f+1) = C(f) + deg;
    }
  }
}

#ifdef IGL_STATIC_LIBRARY
#include <CGAL/Simple_cartesian.h>
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Polyhedron_items_with_id_3.h>
// Explicit template instantiation
// generated by autoexplicit.sh
template void igl::copyleft::cgal::polyhedron_to_mesh<CGAL::Polyhedron_3<CGAL::Simple_cartesian<double>, CGAL::Polyhedron_items_with_id_3, CGAL::HalfedgeDS_default, std::allocator<int>>, Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<int, -1, 1, 0, -1, 1>, Eigen::Matrix<int, -1, 1, 0, -1, 1>>(CGAL::Polyhedron_3<CGAL::Simple_cartesian<double>, CGAL::Polyhedron_items_with_id_3, CGAL::HalfedgeDS_default, std::allocator<int>> const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1>>&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1>>&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, 1, 0, -1, 1>>&);
// generated by autoexplicit.sh
template void igl::copyleft::cgal::polyhedron_to_mesh<CGAL::Polyhedron_3<CGAL::Epick, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator<int> >, Eigen::Matrix<double, -1, 2, 0, -1, 2>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >(CGAL::Polyhedron_3<CGAL::Epick, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator<int> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, 2, 0, -1, 2> >&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> >&);
template void igl::copyleft::cgal::polyhedron_to_mesh<CGAL::Polyhedron_3<CGAL::Epick, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator<int> >, Eigen::Matrix<double, -1, -1, 0, -1, -1>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >(CGAL::Polyhedron_3<CGAL::Epick, CGAL::Polyhedron_items_3, CGAL::HalfedgeDS_default, std::allocator<int> > const&, Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0, -1, -1> >&);
template void igl::copyleft::cgal::polyhedron_to_mesh<CGAL::Polyhedron_3<CGAL::Simple_cartesian<double>,CGAL::Polyhedron_items_with_id_3, CGAL::HalfedgeDS_default, std::allocator<int> >, Eigen::Matrix<double, -1, -1, 0,-1, -1>, Eigen::Matrix<int, -1, -1, 0, -1, -1> >(CGAL::Polyhedron_3<CGAL::Simple_cartesian<double>,CGAL::Polyhedron_items_with_id_3, CGAL::HalfedgeDS_default, std::allocator<int> > const&,Eigen::PlainObjectBase<Eigen::Matrix<double, -1, -1, 0, -1, -1> >&, Eigen::PlainObjectBase<Eigen::Matrix<int, -1, -1, 0,-1, -1> >&);
#endif
